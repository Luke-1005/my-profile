1. make与new的区别
Make 用于map、slice 和channel几种类型的内存分配。并且返回一个有初始值的对象，注意不是指针。

注：channel在make之后打印出来的也是内存地址，是个特殊类型。

New 用于使用type声明的类型的内存分配。new(T)分配了零值填充的T类型的内存空间，并且返回其地址，即一个T类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型T的零值。有一点非常重要：new返回指针。

2. 简要描述go中的main和init函数的区别
首先，这两个函数应用位置不同，init函数可以应用于所有的package，main只能应用于 package main，需要注意的是虽然一个package中可以写任意多个init,但是无论是从可读性还是可维护性来说，都是不推荐的； 其次，这两个函数定义时都不能有任何的参数和返回值， 最后，个人理解，init函数为初始化操作，main函数为程序入口。


3. 下面的代码输出什么，若会报错报什么错？
func main(){
	/*
	先defer的后执行
	recover后输出panic中的信息
	*/
	defer func(){
		If err:=recover();err!=nil{
			fmt.Print(err)
		} else {
			fmt.Print("no")
		}
	}()
	defer func(){
		panic("1111111111111")
	}()
	panic("22222222222")
}
答案：不会报错，而是被recover捕捉，打印出1111111111111

4.  这段代码会输出什么？


答案：先打印出111111111，然后报错（死锁）

说明：两个协程都是读取c2中的元素，然后塞入c1, 然而c2又是无缓冲且没有任何协程在往c2中写数据，所以第一个协程读c2的时候就导致死锁，因为c2永远读不出数据。 如何改能让程序不报错？在第一个协程前加一个协程：


5、简述channel和mutex锁机制的原理异同与使用场景
channel原理： 当channel能存放的元素数量为0时表示为阻塞型channel。当管道无数据时，需要从管道取数据的协程会被阻塞，不会向下执行。 所以可以通过多个协程应用同一个channel，从而实现协程间的同步。

channel使用场景： 1. 需要协程通信时     2. 需要管道传输数据时。

Mutex原理： 互斥锁用来防止资源竞争，多个协程使用同一把排它锁时，原来是并发运行的话将变为线性运行。

排它锁针对任意操作都是排它的，没有读写区分。 若一个goroutine获得锁，则其他goroutine会一直阻塞到他释放锁后才能获得锁。

mutex使用场景： 解决协程并发时对同一资源的竞争问题。

6、sync.WaitGroup的使用场景？
程序中需要并发，需要创建多个goroutine，并且一定要等这些并发全部完成后才继续接下来的程序执行．WaitGroup的特点是Wait()可以用来阻塞直到队列中的所有任务都完成时才解除阻塞，而不需要sleep一个固定的时间来等待．但是其缺点是无法指定固定的goroutine数目（也就是协程池功能）．

7、orm 
.插入
_,err := o.Insert(&user)
.查询-只有Id是参数可以省略
err := o.Read(&user)
5.更新
num, err := o.Update(&user)
删除
num, err := o.Delete(&user
//发送
err := emailConn.Send()

1. Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？
Golang中Goroutine 可以通过 Channel 进行安全读写共享变量。

2. 无缓冲 Chan 的发送和接收是否同步?
ch := make(chan int)    无缓冲的channel由于没有缓冲发送和接收需要同步.
ch := make(chan int, 2) 有缓冲channel不要求发送和接收操作同步. 
channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据。
channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。
Goroutine 是Golang实际并发执行的实体，它底层是使用协程(coroutine)实现并发，coroutine是一种运行在用户态的用户线程，类似于 greenthread，go底层选择使用coroutine的出发点是因为，它具有以下特点：

用户空间 避免了内核态和用户态的切换导致的成本。
可以由语言和框架层进行调度。
更小的栈空间允许创建大量的实例。
Golang中的Goroutine的特性:

Golang内部有三个对象： P对象(processor) 代表上下文（或者可以认为是cpu），M(work thread)代表工作线程，G对象（goroutine）.

正常情况下一个cpu对象启一个工作线程对象，线程去检查并执行goroutine对象。碰到goroutine对象阻塞的时候，会启动一个新的工作线程，以充分利用cpu资源。 所有有时候线程对象会比处理器对象多很多.

我们用如下图分别表示P、M、G:

上传文件：
https://studygolang.com/articles/14789?fr=sidebar


根据上述特点，可知：
一、TCP和UDP的区别
1. 连接
TCP： 是面向连接的传输协议，即：传输数据之前必须先建立好连接。
UDP: 是属于无连接的传输协议。

2. 服务对象
TCP: 是点对点的两点之间的服务，即：一条TCP连接只能有两个端点。
UDP: 支持一对一、一对多、多对一、多对多的交互通信。

3. 可靠性
TCP： 是可靠的传输协议，进行的是可靠交付，即：无差错、不丢失、不重复、按序到达等。
UDP： 是不可靠的传输协议，只是尽最大努力交付，不能保证可靠交付。

4. 拥塞控制&流量控制
TCP： 有拥塞控制和流量控制保证数据传输的安全性。
UDP： 没有拥塞控制，当网络拥塞时不会影响源主机的发送效率。

5. 报文长度
TCP： 属于“动态报文长度”，即：TCP的报文长度是根据接收方的窗口大小和当前网络拥塞情况来决定的。
UDP: 是面向报文的，它是保留上面传下来的报文边界，不合并，不拆分。

6. 首部开销
TCP: 首部开销大，因为首部就占了20个字节。
UDP： 首部开销相对小一点，只占了8个字节。 （eg: UDP的8个字节分布在：源端口、目的端口、数据长度、校验和）

TCP 是可靠的传输协议，但传输速度慢；
而UDP 是不可靠的传输协议，但传输速度快；

TCP的适用场景： 要求通信数据的完整性和准确性较高，eg: 文件传输、邮件发送与接收、重要状态的更新等。
UDP的适用场景： 要求通信的响应度高，对数据信息的安全性和完整性要求相对较低，常用于实时通信，eg: 网络电话、网络视频、实时通信等。

HTTP与TCP的区别和联系
https://www.cnblogs.com/baizhanshi/p/8482612.html


HTTP各版本的区别
https://www.cnblogs.com/guanxiying/p/13321603.html