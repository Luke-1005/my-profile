1. php  /  MySQL 一些核心的技术概念 ，php常规概念，get post session ，以及你在之前项目中如何运用的。  
	1)get post区别：
		1、传送方式：get通过地址栏传输，post通过报文传输。
		2、传送长度：get参数有长度限制（受限于url长度），而post无限制
		3、POST请求不能被缓存，POST请求相对GET请求是「安全」的
		4、GET和POST还有一个重大区别，简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包
			对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）
	2） session 和cookie区别
		1，session 在服务器端，cookie 在客户端（浏览器）
		2，session 默认被存在在服务器的一个文件里（不是内存）
		3，session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）
		4，session 可以放在 文件、数据库、或内存中都可以。
	3）include 和 require
		1、加载失败的处理方式不同
			include与require除了在处理引入文件的方式不同外，最大的区别就是：
			include在引入不存文件时产生一个警告且脚本还会继续执行，
			require则会导致一个致命性错误且脚本停止执行。
		2、文件引用方式
			include有返回值，而require没有
		3、执行
			PHP 程序在执行前，就会先读入 require 所指定引入的文件。
			读到 include 的文件时，才将它读进来


2. 比如PHP 你熟悉的框架，哪些用过，有什么优缺点，没有有过的框架，你如何入手。 
答：用过thinkphp，cakephp，laravel。
Laravel很好的支持了composer，扩展方面比cake和TP做的好，社区文档活跃，相较于TP，Lavavel更庞大，安全性也更高，更适合开发大中型项目
ThinkPhp简单、快速，基于MVC和面向对象，易用性较高，是一款简洁实用的轻量级框架。TP5支持了composer安装，配置文件位置变化，支持了闭包函数，验证方式也跟Lavarel相似，数据返回方面也可以使用return进行数据返回。
路由方面cake和TP相对较方便，cake具有自动操作命令行脚本功能，但功能比laravel稍微少些，适合中型应用。

如何入手一个框架，首先找到入口文件，看下路由规则，数据库的操作方法，查看配置文件。然后看是否有相关文档。


3. 在项目中，有没有使用过什么算法，解决的什么问题， 比如之前支付项目中，支付结束后的返回值不一定是直接有的，就需要发起一个轮询机制，轮询中利用了递归在规定时间内一直请求，知道有数据为止。 
5人助力，成功后随机分5元寄件红包，写了一个红包的算法，来分配5个红包，设置一个随机安全上限。


4、ＰＨＰ 写代码的规范，如何用SVN进行管理。 
缩进，变量名，命名空间，注释等
checkout 先update更新，修改后commit提交。自己写的就add

5、 MYSQL 这边注意 MYISAM / InnoDB 的区别，未来会使用哪一种更多，原因是什么
MyISAM不支持事务，而InnoDB支持
InnoDB支持数据行锁定，MyISAM不支持行锁定，只支持锁定整个表 
InnoDB支持外键，MyISAM不支持。
InnoDB的主键范围更大，最大是MyISAM的2倍
InnoDB不支持全文索引，而MyISAM支持
MyISAM支持GIS数据，InnoDB不支持
没有where的count(*)使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器
一般选择innodb如果你的应用程序对查询性能要求较高，就要使用MYISAM了。MYISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。


6、Redis, Memanche，缓存的特点，你的项目中运用过哪些。总结经验是什么。 
	1、Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等。 
	2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。 
	3、虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘 
	4、过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10 
	5、分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从 
	6、存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化） 
	7、灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复 
	8、Redis支持数据的备份，即master-slave模式的数据备份。
	
	项目中用过redis较多，支持类型多，数据持久化和主从复制时。用来处理高并发的情形，如存储用户session，把用户访问信息放入redis队列里rpush ，取出lpop


7、SQL 语句如何考虑安全性， 比如防止SQL注入。 
防sql注入：客户端过滤，转义 SQL 语句中使用的字符串中的特殊字符。


8、如何优化 MySQL 数据库， Join 代替子查询， 多使用事务和外键等。 
	1、建表时选取最适用的字段属性
	2、使用连接（JOIN）来代替子查询
	3、使用联合(UNION)来代替手动创建的临时表
	4、维护数据库完整性在进行多条操作时使用事务，锁定表
	5、关联性  使用外键
	6、索引是提高数据库性能
	7、判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引
	8、优化的查询语句，创建索引，复合索引，索引不会包含有NULL值的列，使用短索引，like语句操作前面有%不会用到索引，不要在列上进行运算，不使用NOT IN和<>操作

9、MYSQL, 主键，外键，索引，唯一索引 的概念。 

10、还有就是MYSQL 有个锁的概念，一般运用在什么场景。
	事务需要更新大部分或全部数据，表又比较大或事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚使用表锁
	悲观锁（读数据时加锁）：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量
	乐观锁（写数据时加锁）：在读多写少的并发场景下，可以避免数据库加锁的开销
	
	
11、linux操作
find	grep	sudo	kill	查看进程ps -ef	解压 tar	安装rpm		vim到某行 80gg


12、学员信息加密
直接在数据库层面加密存储，使用mysql自带函数AES_DECRYPT() 和AES_ENCRYPT()  HEX()

13、salesforce 交互有哪些数据形式，如何加密
xml  json
对称加密openssl_encrypt
公钥加密私钥解密或私钥加密公钥解密

14、团队合作流程，文档
团队需求分析，概要设计，详细设计，编码，测试

15、和infosys 有团队，写类库的做技术支持

16、阿里云配置
配置安全组


——————————————————————————————————————————————————————————————————————
常见面试题：
1、冒泡排序，面试前一定要记住哦！

function maopao($arr)

{

    $len = count($arr);

    $n = count($arr) - 1;

    for ($i = 0; $i < $len; $i++) {

        for ($j = 0; $j < $n; $j++) {

            if ($arr[$j] > $arr[$j + 1]) {

                $tmp = $arr[$j];

                $arr[$j] = $arr[$j + 1];

                $arr[$j + 1] = $tmp;

            }

        }

    }

    return $arr;

}

2、快速排序，面试前一定要记住哦！

function quick_sort($array) {

    if (count($array) <= 1) return $array;

    $key = $array[0];

    $left_arr = array();

    $right_arr = array();

    for ($i=1; $i
        if ($array[$i] <= $key)

            $left_arr[] = $array[$i];

        else

            $right_arr[] = $array[$i];

    }

    $left_arr = quick_sort($left_arr);

    $right_arr = quick_sort($right_arr);

    return array_merge($left_arr, array($key), $right_arr);

}

3、请说明 PHP 中传值与传引用的区别，什么时候传值什么时候传引用?

按值传递：函数范围内对值的任何改变在函数外部都会被忽略

按引用传递：函数范围内对值的任何改变在函数外部也能反映出这些修改

优缺点：按值传递时，php必须复制值。特别是对于大型的字符串和对象来说，这将会是一个代价很大的操作。按引用传递则不需要复制值，对于性能提高很有好处。（优缺点会考到）

4、MySQL数据库中的字段类型varchar和char的主要区别是什么?

Varchar是变长，节省存储空间，char是固定长度。查找效率要char型快，因为varchar是非定长，必须先查找长度，然后进行数据的提取，比char定长类型多了一个步骤，所以效率低一些。

5、MySQL数据库的常用存储引擎以及它们的区别？

MyISAM：不支持事务，表锁，易产生碎片，要经常优化，读写速度较快，支持全文索引。

InnoDB：支持事务，行锁，有崩溃恢复能力。读写速度比MyISAM慢，5.6之后支持全文索引。
存储引擎是基于表的，而不是数据库

（这道题还能更详细点就详细点）

6、对于大流量的网站，采用什么样的方法来解决访问量问题？

首先，确认服务器硬件是否足够支持当前的流量

其次，优化数据库访问。

第三，禁止外部的盗链。

第四，控制大文件的下载。

第五，使用不同主机分流主要流量

第六，使用流量分析统计软件

第七，尽量使用静态页，缓存

7、什么是面向对象？主要特征是什么？

面向对象是程序的一种设计方式，它利于提高程序的重用性，使程序结构更加清晰。主要特征：封装、继承、多态。

8、SESSION 与 COOKIE的区别是什么？这是重点

SESSION存储在服务器端，COOKIE保存在客户端。Session比较安全，cookie用某些手段可以修改，不安全。Session依赖于cookie进行传递。禁用cookie后，session还可以使用，在存储session的文件中，生成sessionID，通过get传参的方式将sessionID传到要实现session共享的页面，读取sessionID,从而从session中获取数据。

建议查找session与cookie这方面的详细教程

9、对缓存技术的了解？redis是个考点

1、缓存技术是将动态内容缓存到文件中，在一定时间内访问动态页面直接调用缓存文件，而不必重新访问数据库。

2、使用memcache可以做缓存。

10、表单中get和post提交方式的区别

get是显式的，数据从url中可以看到，传输的数据量小，安全性低；

post是隐式的，传送的数据量较大，安全性较高

11、优化数据库的方法

选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL

使用连接(JOIN)来代替子查询

适用联合(UNION)来代替手动创建的临时表

事务处理

锁定表、优化事务处理

使用外键，优化锁定表

使用索引

优化查询语句

12、语句include和require的区别是什么？语句include和require的区别是什么？

require是无条件包含，也就是如果一个流程里加入require，无论条件成立与否都会先执行require，当文件不存在或者无法打开的时候，会提示错误，并且会终止程序执行

include有返回值，而require没有(可能因为如此require的速度比include快)，如果被包含的文件不存在的化，那么会提示一个错误，但是程序会继续执行下去

13、redis和memcacahe、mongoDB的区别？

都是非关系型数据库，性能都非常高，但是mongoDB和memcache、redis是不同的两种类型。后两者主要用于数据的缓存，前者主要用在查询和储存大数据方面，是最接近数据库的文档型的非关系数据库。

从数据存储位置上来分，memcache的数据存在内存中，而redis既可以存储在内存中，也可以存储的到磁盘中，达到持久化存储的功能，memcache一旦断电，数据全部丢失，redis可以利用快照和AOF把数据存到磁盘中，当恢复时又从磁盘中读取到内存中，当物理内存使用完毕后，可以把数据写入到磁盘中。

从存储数据的类型上来分，memcache和redis存储的方式都是键值对，只不过redis值的类型比较丰富，有string(字符串),hash(哈希)，list(列表),set(集合)zset(有序集合)，而memcache主要存储的是字符串。

14、PHP的基本变量类型

四种标量类型：boolean （布尔型）、integer （整型）、float （浮点型, 也称作 double)、string （字符串）

两种复合类型：array （数组）、object （对象）

最后是两种特殊类型：resource（资源）、NULL（NULL）

15、静态化如何实现的？伪静态如何实现？

1、 静态化指的是页面静态化，也即生成实实在在的静态文件，也即不需要查询数据库就可以直接从文件中获取数据，指的是真静态。
实现方式主要有两种：

一种是我们在添加信息入库的时候就生成的静态文件，也称为模板替换技术。

一种是用户在访问我们的页面时先判断是否有对应的缓存文件存在，如果存在就读缓存，不存在就读数据库，同时生成缓存文件。

2、伪静态不是真正意义上的静态化，之所以使用伪静态，主要是为了SEO推广，搜索引擎对动态的文件获取难度大，不利于网站的推广。实习原理是基于Apache或Nginx的rewrite机智
主要有两种方式：

一种是直接在配置虚拟机的位置配置伪静态，这个每次修改完成后需要重启web服务器。

另一种采用分布式的，可以在网站的根目录上创建.htaccess的文件，在里面配置相应的重写规则来实现伪静态，这种每次重写时不需要重启web服务器，且结构上比较清晰。

16、Mysql的读写分离?（进阶的会遇到）

读写分离的实现原理就是在执行SQL语句的时候，判断到底是读操作还是写操作，把读的操作转向到读服务器上（从服务器，一般是多台），写的操作转到写的服务器上（主服务器，一般是一台，视数据量来看）。当然为了保证多台数据库数据的一致性，需要主从复制。

17、如何处理负载，高并发？

1、HTML静态化
效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的 网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。
2、图片服务器分离
把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如七牛等
3、数据库集群和库表散列及缓存
数据库的并发连接为100，一台数据库远远不够，可以从读写分离、主从复制，数据库集群方面来着手。另外尽量减少数据库的访问，可以使用缓存数据库如memcache、redis。
4、镜像：
尽量减少下载，可以把不同的请求分发到多个镜像端。
5、负载均衡：
Apache的最大并发连接为1500，只能增加服务器，可以从硬件上着手，如F5服务器。当然硬件的成本比较高，我们往往从软件方面着手。

18、说一下单引号双引号？（基础考点）

单引号内部的变量不会执行， 双引号会执行

单引号解析速度比双引号快。

单引号只能解析部分特殊字符，双引号可以解析所有特殊字符。

19、PHP7的新特性？重点

标量类型声明：PHP 7 中的函数的形参类型声明可以是标量了。在 PHP 5 中只能是类名、接口、array 或者 callable (PHP 5.4，即可以是函数，包括匿名函数)，现在也可以使用 string、int、float和 bool 了。

返回值类型声明：增加了对返回类型声明的支持。 类似于参数类型声明，返回类型声明指明了函数返回值的类型。可用的类型与参数声明中可用的类型相同。

NULL 合并运算符：由于日常使用中存在大量同时使用三元表达式和 isset()的情况，NULL 合并运算符使得变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数。

use 加强：从同一 namespace 导入的类、函数和常量现在可以通过单个 use 语句 一次性导入了

匿名类：现在支持通过new class 来实例化一个匿名类

20、PHP 数组排序

sort() - 以升序对数组排序

rsort() - 以降序对数组排序

asort() - 根据值，以升序对关联数组进行排序

ksort() - 根据键，以升序对关联数组进行排序

arsort() - 根据值，以降序对关联数组进行排序

krsort() - 根据键，以降序对关联数组进行排序

21、建立索引

(普通索引)->

创建:CREATE INDEX <索引名> ON tablename (索引字段)

修改:ALTER TABLE tablename ADD INDEX [索引名] (索引字段)

创表指定索引:CREATE TABLE tablename([...],INDEX[索引名](索引字段))

(唯一索引)->

创建:CREATE UNIQUE <索引名> ON tablename (索引字段)

修改:ALTER TABLE tablename ADD UNIQUE [索引名] (索引字段)

创表指定索引:CREATE TABLE tablename([...],UNIQUE[索引名](索引字段))

(主键)->

它是唯一索引,一般在创建表是建立,格式为:

CREATA TABLE tablename ([...],PRIMARY KEY[索引字段])

22、PHP支持多继承吗？

不支持。PHP中只允许单继承，父类可以被一个子类用关键字“extends”继承。

23、使用过Memcache缓存吗，如果使用过，能够简单的描述一下它的工作原理吗？

Memcahce是把所有的数据保存在内存当中，采用hash表的方式，每条数据又key和value组成，每个key是独一无二的，当要访问某个值的时候先按照找到值，然后返回结果。
Memcahce采用LRU算法来逐渐把过期数据清除掉。

24、优化MYSQL数据库的方法

（1）选择最有效率的表名顺序

（2）WHERE子句中的连接顺序

（3）SELECT子句中避免使用‘*’

（4）用Where子句替换HAVING子句

（5）通过内部函数提高SQL效率

（6）避免在索引列上使用计算。

（7）提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉。

 

(1).选取最适用的字段属性,应该尽量把字段设置为NOT NULL

(2).使用连接（JOIN）来代替子查询(Sub-Queries)

(3).使用联合(UNION)来代替手动创建的临时表

(4).尽量少使用 LIKE 关键字和通配符

(5).使用事务和外键

25、MySQL主从备份的原理？

mysql支持单向、异步复制，复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。

26、error_reporting() 的作用？

设置 PHP 的报错级别并返回当前级别。

27、如何修改session的生存时间

在php.ini 中设置 session.gc_maxlifetime = 1440 //默认时间

代码实现

$lifeTime = 24 * 3600;  // 保存一天

session_set_cookie_params($lifeTime);

session_start();

28、常见的 PHP 安全性攻击

SQL注入：用户利用在表单字段输入SQL语句的方式来影响正常的SQL执行。
防止：

使用mysql_real_escape_string()过滤数据

手动检查每一数据是否为正确的数据类型

使用预处理语句并绑定变量

参数化SQL：是指在设计与数据库链接并访问数据时，在需要填入数值或数据的地方，使用参数 (Parameter) 来给值，用@或？来表示参数。

XSS攻击 ：跨站点脚本攻击，由用户输入一些数据到你的网站，其中包括客户端脚本(通常JavaScript)。如果你没有过滤就输出数据到另一个web页面，这个脚本将被执行。
防止：为了防止XSS攻击，使用PHP的htmlentities()函数过滤再输出到浏览器。

CSRF：跨站点请求伪造，是指一个页面发出的请求，看起来就像是网站的信任用户，但是是伪造的
防止：一般来说，确保用户来自你的表单，并且匹配每一个你发送出去的表单。有两点一定要记住：

对用户会话采用适当的安全措施，例如:给每一个会话更新id和用户使用SSL。

生成另一个一次性的令牌并将其嵌入表单，保存在会话中(一个会话变量)，在提交时检查它。 如laravel中的 _token

代码注入：代码注入是利用计算机漏洞通过处理无效数据造成的。问题出在，当你不小心执行任意代码，通常通过文件包含。写得很糟糕的代码可以允许一个远程文件包含并执行。如许多PHP函数，如require可以包含URL或文件名。
防止代码注入

过滤用户输入

在php.ini中设置禁用allow_url_fopen和allow_url_include。这将禁用require/include/fopen的远程文件

--------------------------------------------
1、这里我们主要利用Redis的setnx的命令来处理高并发。
https://www.php.cn/php-weizijiaocheng-409694.html
setnx 有两个参数。第一个参数表示键。第二个参数表示值。如果当前键不存在，那么会插入当前键，将第二个参数做为值。返回 1。如果当前键存在，那么会返回0。
判断是能加锁成功，（加锁失败的情况下。判断锁是否已经存在，如果锁存在切已经过期，那么删除锁。进行重新加锁）成功进行MySQL数据库操作
加锁失败其他操作
2、redis 队列处理高并发
https://www.cnblogs.com/emmmmmm/p/10061126.html
是把“多线程”转成“单线程”。即使有很多用户同时到达，也是一个个检查并给与抢购资格，一旦库存抢尽，后面的用户就无法继续了。
比如这里我先把库存(可用库存,这里我强调下哈,一般都是商品详情页抢购,后来者进来看到的库存可能不再是后台系统配置的10个库存数了)放入redis队列：
高并发情况，先将用户进入排队队列，用一个线程循环处理从排队队列取出一个用户，判断用户是否已在抢购结果队列，如果在则已抢购，否则未抢购，接着执行库存减1，写入数据库，将此user_id用户同时也进入结果队列

PHP依赖注入：
类A 的功能实现依赖于类B，使用IOC容器来控制依赖，把他通过构造函数、属性或者工厂模式等方法，注入到类A内。
通过a的接口，把b传入；
通过a的构造，把b传入；
通过设置a的属性，把b传入



